##	算法（规律）:

多写几组，找规律

```
0.1     0.2     0.3     0.4
```

n=4，对于0.2，其index=i=2出现的次数

*   (0.1, 0.2) + (0.2)  [1~i], 共 i 次，有前置无后置

*   (0.2, 0.3) + (0.2, 0.3, 0.4)    (i~n], 共 `n-i` 次，无前置有后置

*   (0.1, 0.2, 0.3) + (0.1, 0.2, 0.3, 0.4)  `n-i`次，即前置0.1后也有`n-i`次，有前置有后置

其中，无前置有后置 + 有前置有后置 = 一共 i 次，即 (n-i) * i 。因此总的次数是

```
t = i + (n-i)*i
```

##	疑问

然而不知道为什么，这段代码无法通过最后两个case

```cpp
// codeblock_1 ...

for( i=1; i<=n; i++ ){
	cin>>num;
	t = i + (n-i)*i;
	sigma += num * t;
}
```

这段代码也无法通过最后两个case

```cpp
// codeblock_2 ...

for( i=1; i<=n; i++ ){
	cin>>num;
	sigma += num * ( i + (n-i)*i );
}
```

只有这样才行

```cpp
// codeblock_3 ...

for( i=1; i<=n; i++ ){
	cin>>num;
	sigma += num * i + num * i * (n-i);
	// sigma += num * i * (n-i+1);      // 或者提取公因子
}
```

好奇怪。。按理来说数学上都是一样的，但为啥codeblock_1和codeblock_2无法只能做对两个case？