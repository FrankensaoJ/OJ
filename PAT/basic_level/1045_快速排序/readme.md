##	[原题](https://www.patest.cn/contests/pat-b-practise/1045)： 1045. 快速排序(25)

著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的N个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

例如给定N = 5, 排列是1、3、2、4、5。则：

*	1的左边没有元素，右边的元素都比它大，所以它可能是主元；
*	尽管3的左边元素都比它小，但是它右边的2它小，所以它不能是主元；
*	尽管2的右边元素都比它大，但其左边的3比它大，所以它不能是主元；
*	类似原因，4和5都可能是主元。

因此，有3个元素可能是主元。

###	输入格式

输入在第1行中给出一个正整数N（<= 105）； 第2行是空格分隔的N个不同的正整数，每个数不超过109。

###	输出格式

在第1行中输出有可能是主元的元素个数；在第2行中按递增顺序输出这些元素，其间以1个空格分隔，行末不得有多余空格。

###	输入样例1

	5
	1 3 2 4 5

###	输出样例1

	3
	1 4 5

###	注意

	时间限制： 200 ms
	内存限制： 65536 kB
	代码长度限制： 8000 B
	判题程序： Standard
	作者： CAO, Peng

<br/><br/>

#	题目分析

1.	不动点

	快排每一次划分时，主元都是一个不动点。因此【主元的集合】是【位置不变的数的集合】的一个子集。

2.	左边<主元<右边

	在条件1的基础上，如果一个元素比它左边所有的数都大，那么它就是一个主元。（也等价于主元右边的数都【大于主元】）

3.	解题思路

	首先保存所有输入元素到`originList[]`数组，并备份为`sorted[]`数组。

	```cpp
	for( int i = 0; i < n; ++i ){
		cin>>origin[i];
		ordered[i] = origin[i];
	}
	```

	主元是不动点，所以完全排序后位置也不变，因此我们先对备份数组进行排序，方便后面的位置比较。

	```cpp
	sort( ordered, ordered + n);
	```

	根据1和2，判断过程即为

	```cpp
	if( origin[i] == ordered[i] && origin[i] == maxOfLeft ){...}
	```

4.	动态更新

	比较过程中还有一个关键点，就是 `maxOfLeft` 如何确定。

	一种方法是，对于每一个`origin[i]`，都与它之前所有的元素进行一一对比

	```cpp
	bool isMax = true;
	for( int j = 0; j < i; ++j ){
		if( originList[j] > originList[i] ){
			isMax = false;
		}
	}
	if( isMax ){
		//origin[i] is maxOfLeft
	}
	```

	不过这种方式显然太慢了，把比较过程的耗时从O(n)提升到了O(n^2)，无法通过测试点1和3。

	优化的方法是动态更新`maxOfLeft`

	```cpp
	for( int i = 0; i < n; ++i ){
		if( origin[i] == ordered[i] && origin[i] > maxOfLeft ){
			ans.push_back(origin[i]);
		}
		maxOfLeft = max( origin[i], maxOfLeft );
	}
	```

5.	输出格式

	测试点2的输出结果是`0`，也就是不存在这样的主元。随后还需要输出空行`\n`，否则将被判为格式错误。

	PS：在[1065_单身狗](https://github.com/jJayyyyyyy/cs/tree/master/OJ/PAT/basic_level/1065_%E5%8D%95%E8%BA%AB%E7%8B%97)中，单身人数为0的时候只输出0即可，不输出空行`\n`也算对。

#	部分测试用例

*	test1

		输入
		5
		5 4 3 2 1

		输出
		0
		
		(注意要输出空行)

*	test2

		输入
		5
		1 3 2 4 5

		输出
		3
		1 4 5


